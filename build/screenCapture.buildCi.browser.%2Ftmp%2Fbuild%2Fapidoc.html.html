<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a>esformatter-jsx (v8.0.0)</a>
</h1>
<h4>esformatter plugin: format javascript files that contain React JSX Elements</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.esformatter-jsx">module esformatter-jsx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.esformatter-jsx._restoreTemplateLiterals">
            function <span class="apidocSignatureSpan">esformatter-jsx.</span>_restoreTemplateLiterals
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.esformatter-jsx.setOptions">
            function <span class="apidocSignatureSpan">esformatter-jsx.</span>setOptions
            <span class="apidocSignatureSpan">(opts, esformatter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.esformatter-jsx.stringAfter">
            function <span class="apidocSignatureSpan">esformatter-jsx.</span>stringAfter
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.esformatter-jsx.stringBefore">
            function <span class="apidocSignatureSpan">esformatter-jsx.</span>stringBefore
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">esformatter-jsx.</span>format_jsx</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.esformatter-jsx.format_jsx">module esformatter-jsx.format_jsx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.esformatter-jsx.format_jsx.create">
            function <span class="apidocSignatureSpan">esformatter-jsx.format_jsx.</span>create
            <span class="apidocSignatureSpan">(htmlOptions, jsxOptions, options, esformatter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.esformatter-jsx.format_jsx.replaceJSXExpressionContainers">
            function <span class="apidocSignatureSpan">esformatter-jsx.format_jsx.</span>replaceJSXExpressionContainers
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.esformatter-jsx.format_jsx.restoreJSXExpressionContainers">
            function <span class="apidocSignatureSpan">esformatter-jsx.format_jsx.</span>restoreJSXExpressionContainers
            <span class="apidocSignatureSpan">(source, containers, space, removeSpace)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.esformatter-jsx" id="apidoc.module.esformatter-jsx">module esformatter-jsx</a></h1>


    <h2>
        <a href="#apidoc.element.esformatter-jsx._restoreTemplateLiterals" id="apidoc.element.esformatter-jsx._restoreTemplateLiterals">
        function <span class="apidocSignatureSpan">esformatter-jsx.</span>_restoreTemplateLiterals
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _restoreTemplateLiterals(source) {
  var me = this;

  var templateLiterals = me._templateLiterals.pop();
  templateLiterals = templateLiterals || [];

  templateLiterals.forEach(function (entry) {
    var code = entry.code;
    var replacedWith = entry.replacedWith;

    source = source.split(replacedWith).join(code);
  });

  return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.esformatter-jsx.setOptions" id="apidoc.element.esformatter-jsx.setOptions">
        function <span class="apidocSignatureSpan">esformatter-jsx.</span>setOptions
        <span class="apidocSignatureSpan">(opts, esformatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOptions(opts, esformatter) {
  var me = this;
  opts = opts || {};
  me.opts = opts;
  me._esformatter = esformatter;

  var jsxOptions = opts.jsx || {};

  me.jsxOptions = extend(true, {
    formatJSX: true,
    attrsOnSameLineAsTag: true,
    maxAttrsOnTag: null,
    firstAttributeOnSameLine: false,
    alignWithFirstAttribute: true,
    JSXExpressionsSingleLine: true,
    formatJSXExpressions: true,
    JSXAttributeQuotes: '' }, jsxOptions);

  if (me.jsxOptions.maxAttrsOnTag &lt; 1) {
    me.jsxOptions.maxAttrsOnTag = 1;
  }

  var htmlOptions = jsxOptions.htmlOptions || {};
  me.htmlOptions = extend(true, {
    brace_style: 'collapse', //eslint-disable-line
    indent_char: ' ', //eslint-disable-line
    // indentScripts: "keep",
    indent_size: 2, //eslint-disable-line
    max_preserve_newlines: 2, //eslint-disable-line
    preserve_newlines: true, //eslint-disable-line
    voidElements: [],
    // indent_handlebars: true
    unformatted: unformatted,
    wrap_line_length: 160 //eslint-disable-line
  }, htmlOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.esformatter-jsx.stringAfter" id="apidoc.element.esformatter-jsx.stringAfter">
        function <span class="apidocSignatureSpan">esformatter-jsx.</span>stringAfter
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringAfter(code) {
  var me = this;

  if (!me.jsxOptions.formatJSX) {
    return code;
  }

  var jsxOptions = me.jsxOptions;

  code = libFormat.restoreJSXExpressionContainers(code, me._jsxExpressionContainers, jsxOptions.spaceInJSXExpressionContainers,
jsxOptions.removeSpaceBeforeClosingJSX);

  var htmlOptions = me.htmlOptions;

  var formatter = libFormat.create(htmlOptions, jsxOptions, me.opts, me._esformatter);

  var ast = falafel(code, function (node) {
    if (node.type !== 'JSXElement') {
      return;
    }
    var conditionalParent = findParent(node, 'ConditionalExpression');
    if (conditionalParent) {
      var formatted = formatter.format(node);
      node.update(formatted);
    }
  });

  code = ast.toString();

  // replace the spread operators
  code = code.replace(/____esfmt_spread_sign___\s*:\s*/g, '...');

  ast = falafel(code, function (node) {
    // support for ES7 Decorators
    if (node.type === 'CallExpression' &amp;&amp; node.callee.source().indexOf('____decorator__at_sign___') &gt; -1) {
      node.callee.update(node.callee.source().replace('____decorator__at_sign___', '@'));
    }
    if (node.type === 'Identifier' &amp;&amp; node.source().indexOf('____decorator__at_sign___') &gt; -1) {
      node.update(node.source().replace('____decorator__at_sign___', '@'));
    }
    if (node.type !== 'JSXElement') {
      return;
    }

    var formatted = void 0;
    if (!findParent(node, 'JSXElement')) {
      formatted = formatter.format(node);
      node.update(formatted);
    }
  });

  code = ast.toString();

  // this is to make sure all decorators comments were removed from the source
  code = code.replace(/;\s*\/\*__decorator__semi__open\*\/\n\s*\/\*__decorator__semi__end\*\//g, '');

  var _ignore = me._ignore.pop();

  code = _ignore.stringAfter(code);
  code = me._restoreTemplateLiterals(code);

  return code;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.esformatter-jsx.stringBefore" id="apidoc.element.esformatter-jsx.stringBefore">
        function <span class="apidocSignatureSpan">esformatter-jsx.</span>stringBefore
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringBefore(code) {
  var me = this;
  if (!me.jsxOptions.formatJSX) {
    return code;
  }

  me._ignore = me._ignore || [];

  var _ignore = Object.create(ignore);
  me._ignore.push(_ignore);

  code = _ignore.stringBefore(code);

  me._templateLiterals = me._templateLiterals || [];

  var templateLiterals = [];

  code = falafel(code, function (node) {
    if (node.type === 'ClassProperty') {
      if (node.value) {
        var oldSource = node.source();

        var formattedProp = '' + (node.static ? 'static ' : '') + node.key.source() + ' = ' + node.value.source() + (oldSource.match
(/;$/) ? ';' : '');

        node.update(formattedProp);
      }
    }

    if (node.type === 'TemplateLiteral' &amp;&amp; !findParent(node, 'JSXAttribute') &amp;&amp; !findParent(node, 'TemplateLiteral')) {

      var idx = templateLiterals.length;
      var replaceString = '__TEMPORARY_VARIABLE__PLACEHOLDER___NODE__' + idx + '_';

      templateLiterals.push({
        code: node.source(),
        replacedWith: replaceString
      });

      node.update(replaceString);
    }

    if (node.type === 'ArrowFunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ClassMethod' || node.type
 === 'FunctionExpression' || node.type === 'ObjectMethod') {

      node.update(node.source().replace(/^async\s+function/, 'async function'));
      node.update(node.source().replace(/^async\s+\(\)/, 'async ()'));
    }

    if (node.type === 'Decorator') {
      if (node.parent.type !== 'ClassMethod' &amp;&amp; node.parent.type !== 'ClassProperty') {
        node.update(node.source().replace(/^\s*@/, '____decorator__at_sign___') + ';/*__decorator__semi__open*/\n/*__decorator__semi__end
*/');
      }
    }

    if (node.type === 'SpreadProperty') {
      var _source = node.source().replace(/^\s*\.\.\./, '____esfmt_spread_sign___:');
      node.update(_source);
    }
  }).toString();

  var response = libFormat.replaceJSXExpressionContainers(code);
  me._jsxExpressionContainers = response.containers;
  me._templateLiterals.push(templateLiterals);
  return response.source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.esformatter-jsx.format_jsx" id="apidoc.module.esformatter-jsx.format_jsx">module esformatter-jsx.format_jsx</a></h1>


    <h2>
        <a href="#apidoc.element.esformatter-jsx.format_jsx.create" id="apidoc.element.esformatter-jsx.format_jsx.create">
        function <span class="apidocSignatureSpan">esformatter-jsx.format_jsx.</span>create
        <span class="apidocSignatureSpan">(htmlOptions, jsxOptions, options, esformatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(htmlOptions, jsxOptions, options, esformatter) {

  var ins = {
    htmlOptions: htmlOptions,
    jsxOptions: jsxOptions,
    _keepUnformatted: function _keepUnformatted(tag) {
      var me = this;
      var unformatted = me.htmlOptions.unformatted || [];

      return unformatted.indexOf(tag) &gt; -1;
    },
    prepareToProcessTags: function prepareToProcessTags(source) {
      var me = this;
      var code = falafel(source, function (node) {
        if (node.type === 'JSXElement' &amp;&amp; !node.selfClosing) {
          if (node.children &amp;&amp; node.children.length &gt; 0) {
            if (!me._keepUnformatted(node.openingElement.name.name)) {
              node.openingElement.update(node.openingElement.source() + '\n');
              node.closingElement.update('\n' + node.closingElement.source());
            } else {

              var childrenSource = node.children.map(function (n, idx) {
                var src = n.source().replace(/\n/g, ' ').replace(/\s+/g, ' ');

                var prev = node.children[idx - 1] || {};
                var next = node.children[idx + 1] || {};

                if (src.trim() === '' &amp;&amp; prev.type === 'JSXExpressionContainer' &amp;&amp; next.type === 'JSXExpressionContainer') {
                  src = '';
                }
                return src;
              }).join('').trim();

              var openTag = node.openingElement.source().replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
              var closeTag = node.closingElement.source().replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
              var nSource = openTag + childrenSource + closeTag;

              node.update(nSource);
            }
          }
        }
      });
      return removeEmptyLines(code.toString());
    },
    operateOnOpenTags: function operateOnOpenTags(source, _htmlOptions) {
      var me = this;

      // make sure tags are in a single line
      var ast = falafel(source, function (node) {
        if (node.type === 'JSXOpeningElement') {
          if (node.attributes &amp;&amp; node.attributes.length &gt; (me.jsxOptions.maxAttrsOnTag || 0)) {
            if (node.selfClosing) {
              node.update(node.source().split(/\n/).map(function (line) {
                return line.trim();
              }).join(' '));
            }
          }
        }
      });

      ast = falafel(ast.toString(), function (node) {
        if (node.type === 'JSXOpeningElement') {
          if (node.attributes &amp;&amp; node.attributes.length &gt; (me.jsxOptions.maxAttrsOnTag || 0)) {
            (function () {
              var first = node.attributes[0];
              var firstAttributeInSameLine = me.jsxOptions.firstAttributeOnSameLine;

              var indentSize = _htmlOptions.indent_size || 4;
              var indentChar = _htmlOptions.indent_char || ' ';

              var alignWith = me.jsxOptions.alignWithFirstAttribute ? first.loc.start.column : node.loc.start.column + indentSize
;
              var tabPrefix = new Array(alignWith + 1).join(indentChar);

              var index = 0;
              // console.log( node.attributes );
              node.attributes.forEach(function (cNode) {
                index++; // eslint-disable-line
                if (firstAttributeInSameLine &amp;&amp; index === 1) {
                  // first = false;
                  return;
                }

                cNode.update('\n' + tabPrefix + cNode.source());
              });

              if (me.jsxOptions.closingTagOnNewLine) {
                // If you find a closing tag (including a self-closing tag like /&gt;), add a new line, matching the current alignWith
                var closingTagTabPrefix = new Array(node.loc.start.column + 1).join(indentChar);
                node.update(node.source().replace(/(\/?&gt;)$/, '\n' + closingTagTabPrefix + '$1'));
              }
            })();
          }
        }
      });

      return ast.toString();
    },
    _recursiveFormat: function _recursiveFormat(node) {
      var originalSource = node.source();

      var source = originalSource;

      var code = void 0;

      try {
        if (node.type === ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.esformatter-jsx.format_jsx.replaceJSXExpressionContainers" id="apidoc.element.esformatter-jsx.format_jsx.replaceJSXExpressionContainers">
        function <span class="apidocSignatureSpan">esformatter-jsx.format_jsx.</span>replaceJSXExpressionContainers
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceJSXExpressionContainer(source) {
  var response = [];
  var index = void 0;

  var ast = falafel(source, function (node) {
    if (node.type === 'JSXExpressionContainer') {
      var attribute = false;
      var replacement = void 0;
      index = response.length;

      if (findParent(node, 'JSXAttribute')) {
        attribute = true;
        replacement = '"__JSXattribute_0_' + index + '"';
      } else {
        replacement = '&lt;__JSXExpression_0_' + index + ' /&gt;';
      }

      var loc = node.loc || node.node.loc;

      response.push({
        jsxAttribute: attribute,
        code: node.source(),
        column: loc.start.column
      });

      node.update(replacement);
    }
  });

  return { containers: response, source: ast.toString() };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.esformatter-jsx.format_jsx.restoreJSXExpressionContainers" id="apidoc.element.esformatter-jsx.format_jsx.restoreJSXExpressionContainers">
        function <span class="apidocSignatureSpan">esformatter-jsx.format_jsx.</span>restoreJSXExpressionContainers
        <span class="apidocSignatureSpan">(source, containers, space, removeSpace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restoreContainers(source, containers, space, removeSpace) {

  iterateReverse(containers, function (entry, idx) {
    var container = entry.code;
    var column = entry.column;
    var rx = entry.jsxAttribute ? new RegExp('[\'"]__JSXattribute_0_' + idx + '[\'"]') : new RegExp('&lt;__JSXExpression_0_' + idx + '\\s*\\/&gt;');

    if (!entry.jsxAttribute) {
      container = addSpaces(container, column);
    }

    if (typeof space !== 'string') {
      space = ' '; // 1 space by default
    }
    // this line was causing bug#13
    // source = source.replace( rx, container.replace( /^\{\s*/, '{' + space ).replace( /\s*\}$/, space + '}' ) );
    source = source.split(rx).join(container.replace(/^\{\s*/, '{' + space).replace(/\s*\}$/, space + '}'));
  });

  if (removeSpace === true) {
    source = source.replace(/\s+\/&gt;/g, '/&gt;');
  }

  return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>